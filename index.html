<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>BreathCoach</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            overscroll-behavior-y: contain;
        }
        @keyframes subtle-pulse {
            0%, 100% { stroke-opacity: 0.5; }
            50% { stroke-opacity: 1; }
        }
        .animate-subtle-pulse {
            animation: subtle-pulse 3s ease-in-out infinite;
        }
    </style>
</head>
<body class="bg-black">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
        import React, { useState, useCallback, useEffect, useRef, useMemo } from 'https://esm.sh/react@^19.2.3';
        import ReactDOM from 'https://esm.sh/react-dom@^19.2.3/client';

        // --- Error Boundary Component ---
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null, errorInfo: null };
            }

            static getDerivedStateFromError(error) {
                return { hasError: true, error: error };
            }

            componentDidCatch(error, errorInfo) {
                console.error("Uncaught error:", error, errorInfo);
                this.setState({ errorInfo: errorInfo });
            }

            render() {
                if (this.state.hasError) {
                    return (
                        <div className="w-full max-w-lg mx-auto text-left p-4 bg-gray-900 rounded-lg border border-red-700/50 text-white">
                            <h1 className="text-2xl font-bold text-red-400 mb-2">Something went wrong.</h1>
                            <p className="text-gray-300 mb-4">The application has encountered an error. Please copy the details below and report the issue.</p>
                            <details className="p-2 bg-gray-800 rounded">
                                <summary className="cursor-pointer font-semibold text-red-400">Error Details</summary>
                                <pre className="mt-2 text-sm text-gray-300" style={{ whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                                    {this.state.error && this.state.error.toString()}
                                    <br />
                                    {this.state.errorInfo && this.state.errorInfo.componentStack}
                                </pre>
                            </details>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // --- Shared Types & Constants ---
        const AppState = {
            START: 'START',
            SESSION: 'SESSION',
            SCORE: 'SCORE',
        };

        // --- Shared Utility Functions ---
        const speak = (text, lang = 'en-US') => {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = lang;
                utterance.rate = 1.1;
                window.speechSynthesis.speak(utterance);
            }
        };

        // --- Breathing Analysis Logic ---
        const TARGET_BPM = 6;
        const getStandardDeviation = (arr) => {
            if (arr.length < 2) return 0;
            const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length;
            const variance = arr.reduce((acc, val) => acc + (val - mean) ** 2, 0) / arr.length;
            return Math.sqrt(variance);
        };
        const calculateResonanceScore = (sessionData) => {
            const { breaths } = sessionData;
            if (breaths.length < 3) return { resonance: 0, rhythm: 0, avgBPM: 0 };
            
            const intervals = [];
            for (let i = 1; i < breaths.length; i++) {
                intervals.push((breaths[i].timestamp - breaths[i - 1].timestamp) / 1000);
            }
            
            if (intervals.length === 0) return { resonance: 0, rhythm: 0, avgBPM: 0 };
            
            const averageInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;
            const avgBPM = 60 / averageInterval;
            
            const freqDifference = Math.abs(avgBPM - TARGET_BPM);
            const frequencyScore = Math.max(0, 100 - (freqDifference / 4) * 100);
            
            const stdDev = getStandardDeviation(intervals);
            const rhythmPenalty = (stdDev / averageInterval) * 400;
            const rhythmScore = Math.max(0, 100 - rhythmPenalty);
            
            const resonance = (frequencyScore * 0.6) + (rhythmScore * 0.4);
            
            return {
                resonance: Math.round(resonance),
                rhythm: Math.round(rhythmScore),
                avgBPM,
            };
        };

        // --- Motion Sensor Hook ---
        const useMotionSensors = () => {
            const [filteredData, setFilteredData] = useState([]);
            const [breathsPerMinute, setBreathsPerMinute] = useState(0);
            const [recordedBreaths, setRecordedBreaths] = useState([]);
            const [hasReceivedData, setHasReceivedData] = useState(false);

            const isListeningRef = useRef(false);
            const animationFrameId = useRef(null);
            
            const rawBetaRef = useRef(null);
            const baselineRef = useRef(null);
            const filteredValueRef = useRef(null);
            const lastPeakTimeRef = useRef(null);
            const lastDirectionRef = useRef(0);
            const breathTimestampsRef = useRef([]);
            const lastFilteredValueRef = useRef(0);

            const processData = useCallback(() => {
                if (!isListeningRef.current) return;
                animationFrameId.current = requestAnimationFrame(processData);

                const beta = rawBetaRef.current;
                if (beta === null) return;
                
                if (!hasReceivedData) setHasReceivedData(true);

                if (baselineRef.current === null) {
                    baselineRef.current = beta;
                }

                const currentRawValue = beta - baselineRef.current;
                
                const LOW_PASS_ALPHA = 0.1; 
                let newFilteredValue = filteredValueRef.current === null
                    ? currentRawValue
                    : LOW_PASS_ALPHA * currentRawValue + (1 - LOW_PASS_ALPHA) * filteredValueRef.current;
                filteredValueRef.current = newFilteredValue;

                setFilteredData(prev => {
                    const newData = [...prev, newFilteredValue];
                    return newData.length > 200 ? newData.slice(1) : newData;
                });

                const prevFilteredValue = lastFilteredValueRef.current;
                const currentDirection = Math.sign(newFilteredValue - prevFilteredValue);

                if (currentDirection === -1 && lastDirectionRef.current === 1 && Math.abs(newFilteredValue - prevFilteredValue) > 0.03) {
                    const now = Date.now();
                    if (lastPeakTimeRef.current === null || (now - lastPeakTimeRef.current) > 2000) {
                        breathTimestampsRef.current.push(now);
                        setRecordedBreaths(prev => [...prev, { timestamp: now }]);
                        if (navigator.vibrate) navigator.vibrate(50);
                        lastPeakTimeRef.current = now;
                    }
                }
                lastDirectionRef.current = currentDirection;
                lastFilteredValueRef.current = newFilteredValue;

                const now = Date.now();
                const recentBreaths = breathTimestampsRef.current.filter(t => now - t < 15000);
                if (recentBreaths.length > 1) {
                    const secondsElapsed = (recentBreaths[recentBreaths.length - 1] - recentBreaths[0]) / 1000;
                    const bpm = (recentBreaths.length - 1) / secondsElapsed * 60;
                    setBreathsPerMinute(bpm);
                }
            }, [hasReceivedData]);
            
            const handleMotionEvent = useCallback((event) => {
                rawBetaRef.current = event.beta;
            }, []);

            const startListening = useCallback(() => {
                if (isListeningRef.current) return;
                isListeningRef.current = true;
                setHasReceivedData(false);
                rawBetaRef.current = null;
                baselineRef.current = null;
                filteredValueRef.current = null;
                lastPeakTimeRef.current = null;
                lastDirectionRef.current = 0;
                lastFilteredValueRef.current = 0;
                breathTimestampsRef.current = [];
                setFilteredData([]);
                setRecordedBreaths([]);
                setBreathsPerMinute(0);
                
                window.addEventListener('deviceorientation', handleMotionEvent);
                animationFrameId.current = requestAnimationFrame(processData);
            }, [handleMotionEvent, processData]);

            const stopListening = useCallback(() => {
                isListeningRef.current = false;
                window.removeEventListener('deviceorientation', handleMotionEvent);
                if (animationFrameId.current) {
                    cancelAnimationFrame(animationFrameId.current);
                    animationFrameId.current = null;
                }
            }, [handleMotionEvent]);

            return { filteredData, breathsPerMinute, recordedBreaths, hasReceivedData, startListening, stopListening };
        };

        // --- BreathingVisualizer Component ---
        const BreathingVisualizer = ({ data }) => {
            const pathData = useMemo(() => {
                if (data.length < 2) return 'M 0 50';
                
                const MAX_POINTS = 200, FIXED_MIN = -5, FIXED_MAX = 5;
                const width = 100, height = 100, step = width / (MAX_POINTS - 1), range = FIXED_MAX - FIXED_MIN;
                let path = '';
                for (let i = 0; i < data.length; i++) {
                    const command = i === 0 ? 'M' : 'L';
                    const x = i * step;
                    const clampedValue = Math.max(FIXED_MIN, Math.min(FIXED_MAX, data[i]));
                    const normalizedValue = (clampedValue - FIXED_MIN) / range * 2 - 1;
                    const y = height / 2 - (height / 2 - 10) * normalizedValue;
                    path += ` ${command} ${x.toFixed(2)},${y.toFixed(2)}`;
                }
                return path.trim();
            }, [data]);
            
            return (
                <div className="w-full h-full">
                    <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
                        <path d={pathData} fill="none" stroke="#FFFFFF" strokeWidth="0.5" strokeLinejoin="round" strokeLinecap="round" />
                    </svg>
                </div>
            );
        };

        // --- StartScreen Component ---
        const PlacementGraphic = () => (
            <div className="w-56 h-56 mx-auto my-6 relative">
                <svg viewBox="0 0 100 100" className="w-full h-full">
                    <g stroke="#4a4a4a" strokeWidth="2" fill="none" strokeLinecap="round" strokeLinejoin="round">
                        {/* Shoulders */}
                        <path d="M20,20 H 80" />
                        {/* Torso Sides */}
                        <path d="M20,20 C 15,50 30,90 40,90" />
                        <path d="M80,20 C 85,50 70,90 60,90" />
                        {/* Bottom line */}
                        <path d="M40,90 H 60" />
                    </g>
                     {/* Phone Outline */}
                    <rect x="36" y="50" width="28" height="45" rx="4" fill="none" stroke="#FFFFFF" strokeWidth="1.5" className="animate-subtle-pulse" />
                </svg>
            </div>
        );

        const SpiritLevel = ({ beta, gamma }) => {
            const tolerance = 15;
            const isFlat = beta !== null && gamma !== null && Math.abs(beta) < tolerance && Math.abs(gamma) < tolerance;
            const clampedGamma = Math.max(-20, Math.min(20, gamma || 0));
            const clampedBeta = Math.max(-20, Math.min(20, beta || 0));
            const dotX = 50 + clampedGamma * 1.8;
            const dotY = 50 + clampedBeta * 1.8;

            return (
                <div className="my-4 flex flex-col items-center">
                    <svg viewBox="0 0 100 100" className="w-24 h-24">
                        <defs>
                            <filter id="glow">
                                <feGaussianBlur stdDeviation="3.5" result="coloredBlur" />
                                <feMerge>
                                    <feMergeNode in="coloredBlur" />
                                    <feMergeNode in="SourceGraphic" />
                                </feMerge>
                            </filter>
                        </defs>
                        <circle cx="50" cy="50" r="45" fill="#1a1a1a" />
                        <circle cx="50" cy="50" r="40" stroke={isFlat ? '#ffffff' : '#4a4a4a'} strokeWidth="2" fill="transparent" style={{ transition: 'stroke 0.3s ease-in-out' }} />
                        <circle cx="50" cy="50" r="15" fill={isFlat ? 'rgba(255, 255, 255, 0.1)' : 'rgba(255, 255, 255, 0.05)'} style={{ transition: 'fill 0.3s ease-in-out' }} />
                        <circle 
                            cx={dotX} 
                            cy={dotY} 
                            r="8" 
                            fill={'#ffffff'} 
                            style={{ 
                                transition: 'cx 0.1s ease-out, cy 0.1s ease-out, opacity 0.3s ease-in-out, filter 0.3s ease-in-out',
                                opacity: isFlat ? 1 : 0.7,
                                filter: isFlat ? 'url(#glow)' : 'none'
                            }} 
                        />
                    </svg>
                </div>
            );
        };
        const StartScreen = ({ onStart, onActivateAudio }) => {
            const [permissionState, setPermissionState] = useState('idle');
            const [orientation, setOrientation] = useState({ beta: null, gamma: null });
            const [error, setError] = useState(null);
            const [countdown, setCountdown] = useState(null);
            const [isStabilizing, setIsStabilizing] = useState(false);
            
            const tolerance = 15;
            const isFlat = orientation.beta !== null && orientation.gamma !== null && Math.abs(orientation.beta) < tolerance && Math.abs(orientation.gamma) < tolerance;
            const stabilityTimerRef = useRef(null);

            const handleDeviceOrientation = useCallback((event) => {
                setOrientation({ beta: event.beta, gamma: event.gamma });
            }, []);

            const requestPermission = useCallback(async () => {
                setError(null);
                setPermissionState('requesting');

                onActivateAudio();

                if (typeof (DeviceOrientationEvent).requestPermission === 'function') {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        if (permission === 'granted') {
                            setPermissionState('granted');
                            window.addEventListener('deviceorientation', handleDeviceOrientation);
                        } else {
                            setPermissionState('denied');
                            setError('Sensor access denied. Please enable it in your browser settings.');
                        }
                    } catch (err) {
                        setPermissionState('denied');
                        setError('An error occurred while requesting sensor access.');
                    }
                } else {
                    setPermissionState('granted');
                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                }
            }, [handleDeviceOrientation, onActivateAudio]);

            useEffect(() => {
                if (isStabilizing) return;
                
                if (stabilityTimerRef.current) {
                    clearTimeout(stabilityTimerRef.current);
                    stabilityTimerRef.current = null;
                }

                if (permissionState !== 'granted' || !isFlat) {
                    if (countdown !== null) setCountdown(null);
                    return;
                }

                if (countdown === null) {
                    setIsStabilizing(true);
                    stabilityTimerRef.current = setTimeout(() => {
                        setIsStabilizing(false);
                        setCountdown(3);
                        speak("3");
                    }, 2000);
                }
            }, [isFlat, permissionState, countdown, isStabilizing]);

            useEffect(() => {
                if (countdown === null) return;
                if (countdown === 0) {
                    onStart();
                    return;
                }
                const timerId = setTimeout(() => {
                    const nextCount = countdown - 1;
                    if (nextCount > 0) speak(String(nextCount));
                    setCountdown(nextCount);
                }, 1000);
                return () => clearTimeout(timerId);
            }, [countdown, onStart]);
            
            useEffect(() => {
                return () => window.removeEventListener('deviceorientation', handleDeviceOrientation);
            }, [handleDeviceOrientation]);
            
            const renderStatus = () => {
                if (countdown !== null) return <p className="text-8xl font-bold text-white">{countdown}</p>;
                if (isStabilizing) return <p className="font-semibold text-gray-300 animate-pulse">Hold steady...</p>;
                if (orientation.beta === null) return <p className="font-semibold text-gray-300">Place phone on your belly...</p>;

                const { beta, gamma } = orientation;
                const betaAbs = Math.abs(beta);
                const gammaAbs = Math.abs(gamma);

                if (betaAbs > tolerance || gammaAbs > tolerance) {
                    if (betaAbs > gammaAbs) {
                        return <p className="font-semibold text-gray-300">{beta > tolerance ? 'Tilt top of phone down' : 'Tilt top of phone up'}</p>;
                    } else {
                        return <p className="font-semibold text-gray-300">{gamma > tolerance ? 'Tilt phone to the left' : 'Tilt phone to the right'}</p>;
                    }
                }
                
                return <p className="font-semibold text-gray-300">Great! Keep it flat.</p>;
            };

            return (
                <div className="w-full max-w-md mx-auto text-center p-8 bg-gray-900/50 rounded-2xl shadow-2xl backdrop-blur-lg border border-gray-700/50">
                    <h1 className="text-4xl font-bold text-white mb-2 tracking-wide">BreathCoach</h1>
                    <p className="text-gray-400 mb-2">Lie down and place your phone on the highlighted area.</p>
                    <PlacementGraphic />
                    <SpiritLevel beta={orientation.beta} gamma={orientation.gamma} />
                    {error && <p className="text-red-400 mt-4">{error}</p>}
                    {permissionState !== 'granted' ? (
                        <button onClick={requestPermission} disabled={permissionState === 'requesting'} className="mt-4 w-full bg-white text-black font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-gray-200 focus:outline-none focus:ring-4 focus:ring-gray-500/50 transition-all duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50">
                            {permissionState === 'requesting' ? 'Requesting...' : 'Allow Sensor Access'}
                        </button>
                    ) : (
                        <div className="mt-4 h-20 flex items-center justify-center text-lg">{renderStatus()}</div>
                    )}
                </div>
            );
        };

        // --- SessionScreen Component ---
        const SessionScreen = ({ onSessionComplete, audioContext }) => {
            const SESSION_DURATION = 60;
            const [timeLeft, setTimeLeft] = useState(SESSION_DURATION);
            const { filteredData, breathsPerMinute, recordedBreaths, hasReceivedData, startListening, stopListening } = useMotionSensors();
            const [sensorError, setSensorError] = useState(false);

            const breathsRef = useRef(recordedBreaths);
            useEffect(() => { breathsRef.current = recordedBreaths; }, [recordedBreaths]);
            
            useEffect(() => {
                startListening();
                speak("Begin breathing. Follow the tones.");

                const timer = setInterval(() => {
                    setTimeLeft(prevTime => {
                        if (prevTime <= 1) {
                            clearInterval(timer);
                            return 0;
                        }
                        return prevTime - 1;
                    });
                }, 1000);

                const sensorCheck = setTimeout(() => {
                    if (!hasReceivedData) {
                        setSensorError(true);
                    }
                }, 4000);
                
                let audioGuide = null;
                if (audioContext && audioContext.state === 'running') {
                    const gain = audioContext.createGain();
                    gain.gain.setValueAtTime(0, audioContext.currentTime);
                    gain.connect(audioContext.destination);

                    const oscillators = [
                        { freq: 392.00, gain: 0.3, type: 'sine' }, // Inhale
                        { freq: 261.63, gain: 0.3, type: 'sine' }  // Exhale
                    ];

                    let isPlaying = true;
                    
                    const playCycle = () => {
                        if (!isPlaying) return;
                        
                        const now = audioContext.currentTime;
                        
                        const inhaleOsc = audioContext.createOscillator();
                        inhaleOsc.type = oscillators[0].type;
                        inhaleOsc.frequency.setValueAtTime(oscillators[0].freq, now);
                        const inhaleGain = audioContext.createGain();
                        inhaleGain.gain.setValueAtTime(0, now);
                        inhaleGain.gain.linearRampToValueAtTime(oscillators[0].gain, now + 0.5);
                        inhaleGain.gain.linearRampToValueAtTime(0, now + 4);
                        inhaleOsc.connect(inhaleGain).connect(audioContext.destination);
                        inhaleOsc.start(now);
                        inhaleOsc.stop(now + 4);

                        const exhaleOsc = audioContext.createOscillator();
                        exhaleOsc.type = oscillators[1].type;
                        exhaleOsc.frequency.setValueAtTime(oscillators[1].freq, now + 4);
                         const exhaleGain = audioContext.createGain();
                        exhaleGain.gain.setValueAtTime(0, now + 4);
                        exhaleGain.gain.linearRampToValueAtTime(oscillators[1].gain, now + 4.5);
                        exhaleGain.gain.linearRampToValueAtTime(0, now + 10);
                        exhaleOsc.connect(exhaleGain).connect(audioContext.destination);
                        exhaleOsc.start(now + 4);
                        exhaleOsc.stop(now + 10);
                        
                        audioGuide = setTimeout(playCycle, 10000);
                    };
                    playCycle();

                    return () => {
                        isPlaying = false;
                        clearTimeout(audioGuide);
                        clearInterval(timer);
                        clearTimeout(sensorCheck);
                        stopListening();
                    };
                }

                return () => {
                    clearInterval(timer);
                    clearTimeout(sensorCheck);
                    stopListening();
                };
            }, [audioContext, startListening, stopListening, hasReceivedData]);

            useEffect(() => {
                if (timeLeft === 0) {
                    stopListening();
                    onSessionComplete({ breaths: breathsRef.current, duration: SESSION_DURATION });
                }
            }, [timeLeft, onSessionComplete, stopListening]);

            const formattedTime = useMemo(() => `${Math.floor(timeLeft / 60).toString().padStart(2, '0')}:${(timeLeft % 60).toString().padStart(2, '0')}`, [timeLeft]);

            if (sensorError) {
                return (
                    <div className="w-full max-w-md mx-auto text-center p-8 bg-gray-900/50 rounded-lg">
                        <h2 className="text-2xl font-bold text-red-400 mb-4">Sensor Error</h2>
                        <p className="text-gray-300">Could not read motion sensor data. Please ensure your browser has permission and your device supports it.</p>
                        <button onClick={() => window.location.reload()} className="mt-6 bg-white text-black font-bold py-2 px-4 rounded-lg">
                            Reload
                        </button>
                    </div>
                );
            }

            return (
                <div className="w-full h-full flex flex-col items-center justify-center p-4">
                    <div className="w-full max-w-4xl mx-auto flex flex-col items-center justify-center flex-grow relative">
                        <div className="absolute top-4 right-4 text-center"><div className="text-gray-400 text-sm">TIME LEFT</div><div className="text-4xl font-mono font-bold text-white">{formattedTime}</div></div>
                        <div className="absolute top-4 left-4 text-center"><div className="text-gray-400 text-sm">LIVE RATE</div><div className="text-4xl font-mono font-bold text-white">{breathsPerMinute.toFixed(1)}</div><div className="text-gray-400 text-xs">BPM</div></div>
                        <div className="w-full h-64 md:h-96"><BreathingVisualizer data={filteredData} /></div>
                        <div className="mt-8 text-center"><p className="text-xl text-gray-200">Breathe slowly and deeply with your belly.</p><p className="text-md text-gray-400">Follow the audio guide.</p></div>
                    </div>
                </div>
            );
        };

        // --- ScoreScreen Component ---
        const ScoreCircle = ({ score }) => {
            const circumference = 2 * Math.PI * 56;
            const offset = circumference - (score / 100) * circumference;
            return (
                <div className="relative w-40 h-40">
                    <svg className="w-full h-full" viewBox="0 0 120 120">
                        <circle className="text-gray-700" strokeWidth="8" stroke="currentColor" fill="transparent" r="56" cx="60" cy="60" />
                        <circle className="text-white" strokeWidth="8" strokeDasharray={circumference} strokeDashoffset={offset} strokeLinecap="round" stroke="currentColor" fill="transparent" r="56" cx="60" cy="60" style={{ transition: 'stroke-dashoffset 1.5s ease-in-out' }} transform="rotate(-90 60 60)" />
                    </svg>
                    <div className="absolute inset-0 flex flex-col items-center justify-center">
                        <span className="text-5xl font-bold text-white">{Math.round(score)}</span>
                        <span className="text-sm text-gray-400">Score</span>
                    </div>
                </div>
            );
        };
        const ScoreScreen = ({ sessionData, onRestart }) => {
            const score = useMemo(() => calculateResonanceScore(sessionData), [sessionData]);
            
            useEffect(() => { speak("Session complete. Here is your resonance score."); }, []);
            
            const feedback = useMemo(() => {
                if (score.resonance >= 85) return "Excellent! You've achieved a state of high resonance.";
                if (score.resonance >= 70) return "Great job! Your breathing is calm and consistent.";
                if (score.resonance >= 50) return "Good effort. Try to maintain a more steady rhythm.";
                return "Keep practicing. Focus on slow, regular belly breaths.";
            }, [score.resonance]);

            return (
                <div className="w-full max-w-md mx-auto text-center p-8 bg-gray-900/50 rounded-2xl shadow-2xl backdrop-blur-lg border border-gray-700/50">
                    <h2 className="text-3xl font-bold text-white mb-2">Session Complete</h2>
                    <p className="text-gray-300 mb-8">{feedback}</p>
                    <div className="flex justify-center mb-8"><ScoreCircle score={score.resonance} /></div>
                    <div className="grid grid-cols-2 gap-4 text-left p-6 bg-black/60 rounded-lg border border-gray-700/60">
                        <div><p className="text-sm text-gray-400">Avg. Breath Rate</p><p className="text-2xl font-bold text-white">{score.avgBPM.toFixed(1)} <span className="text-lg font-normal">BPM</span></p></div>
                        <div><p className="text-sm text-gray-400">Rhythm Score</p><p className="text-2xl font-bold text-white">{Math.round(score.rhythm)}<span className="text-lg font-normal">/100</span></p></div>
                    </div>
                    <button onClick={onRestart} className="mt-8 w-full bg-white text-black font-bold py-3 px-4 rounded-lg shadow-lg hover:bg-gray-200 focus:outline-none focus:ring-4 focus:ring-gray-500/50 transition-all duration-300 ease-in-out transform hover:scale-105">Try Another Session</button>
                </div>
            );
        };

        // --- Main App Component ---
        const App = () => {
            const [appState, setAppState] = useState(AppState.START);
            const [sessionData, setSessionData] = useState(null);
            const audioContextRef = useRef(null);

            const handleActivateAudio = useCallback(() => {
                if (!audioContextRef.current) {
                    try {
                        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
                    } catch (e) { console.error("Web Audio API is not supported.", e); }
                }
                if (audioContextRef.current?.state === 'suspended') {
                    audioContextRef.current.resume();
                }
            }, []);
            
            const handleSessionStart = useCallback(() => setAppState(AppState.SESSION), []);
            
            const handleSessionComplete = useCallback((data) => {
                setSessionData(data);
                setAppState(AppState.SCORE);
            }, []);
            
            const handleRestart = useCallback(() => {
                setSessionData(null);
                setAppState(AppState.START);
            }, []);
            
            const renderContent = () => {
                switch (appState) {
                    case AppState.SESSION: 
                        return <SessionScreen onSessionComplete={handleSessionComplete} audioContext={audioContextRef.current} />;
                    case AppState.SCORE: 
                        return sessionData ? <ScoreScreen sessionData={sessionData} onRestart={handleRestart} /> : <StartScreen onStart={handleSessionStart} onActivateAudio={handleActivateAudio} />;
                    case AppState.START:
                    default: 
                        return <StartScreen onStart={handleSessionStart} onActivateAudio={handleActivateAudio} />;
                }
            };
            
            return (
                <main className="bg-black min-h-screen w-full flex flex-col items-center justify-center text-white p-4 font-sans antialiased">
                    <ErrorBoundary>
                        {renderContent()}
                    </ErrorBoundary>
                </main>
            );
        };

        // --- Mount the App ---
        const rootElement = document.getElementById('root');
        if (rootElement) {
            const root = ReactDOM.createRoot(rootElement);
            root.render(<App />);
        }
    </script>
</body>
</html>